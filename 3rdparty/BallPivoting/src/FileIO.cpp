/** @file FileIO.cpp
 * @brief file defining methods to read points from a file
 * see FileIO.h for methods declaration
 * @author Julie Digne julie.digne@liris.cnrs.fr
 * @date 2012/10/22
 * @copyright This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published 
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
 */


#include "FileIO.h"
#include<iostream>
#include<fstream>
#include<istream>
#include<ostream>
#include<sstream>
#include <limits>

using namespace std;

namespace pba {
    FileIO::FileIO() {
    }

    FileIO::~FileIO() {
    }


    bool FileIO::readAndSortPoints(const char *filename, Octree &octree,
                                   double min_radius) {
        ifstream in;
        in.open(filename);

        if (!in) {
            std::cerr << "File " << filename << " could not be opened" << std::endl;
            return false;
        }

        string firstline;

        getline(in, firstline);

        istringstream line_in(firstline);
        string word;
        int nword = 0;
        while (line_in >> word)
            nword++;

        if (nword == 3) {
            std::cerr << "Only three doubles per line: unoriented points?"
                      << "This program needs oriented points!" << endl;
            return false;
        }

        if (nword != 6) {
            std::cerr << "each point must be given by 6 values (position + normal) :"
                      << "x y z nx ny nz" << endl;
            return false;
        }

        in.clear();
        in.seekg(0, ios::beg);

        double x, y, z, nx, ny, nz;
        in >> x >> y >> z >> nx >> ny >> nz;

        list<Vertex> input_vertices;
        input_vertices.push_back(Vertex(x, y, z, nx, ny, nz));

        double xmin, ymin, zmin, xmax, ymax, zmax;
        xmin = xmax = x;
        ymin = ymax = y;
        zmin = zmax = z;

        while (in >> x >> y >> z >> nx >> ny >> nz) {
            input_vertices.push_back(Vertex(x, y, z, nx, ny, nz));

            xmin = x < xmin ? x : xmin;
            xmax = x > xmax ? x : xmax;
            ymin = y < ymin ? y : ymin;
            ymax = y > ymax ? y : ymax;
            zmin = z < zmin ? z : zmin;
            zmax = z > zmax ? z : zmax;
        }
        in.close();

        std::cout << input_vertices.size() << " points read" << std::endl;

        double lx = xmax - xmin;
        double ly = ymax - ymin;
        double lz = zmax - zmin;

        double size = lx > ly ? lx : ly;
        size = size > lz ? size : lz;


        size = 1.1 * size;
        double margin;


        if (min_radius > 0) {
            unsigned int depth = (unsigned int) ceil(log2(size / (min_radius)));
            double adapted_size = pow2(depth) * min_radius;
            margin = 0.5 * (adapted_size - size);
            size = adapted_size;
            octree.setDepth(depth);
        } else {
            margin = 0.05 * size;
        }

        double ox = xmin - margin;
        double oy = ymin - margin;
        double oz = zmin - margin;
        Point origin(ox, oy, oz);

        octree.initialize(origin, size);

        octree.addPoints(input_vertices.begin(), input_vertices.end());

        return true;
    }

    bool FileIO::savePoints(const char *filename, Octree &octree) {
        ofstream out;
        out.open(filename);
        out.precision(numeric_limits<double>::digits10 + 1);

        if (!out)
            return false;

        OctreeNode *node = octree.getRoot();
        saveContent(node, out);

        out.close();

        return true;
    }


    bool FileIO::saveMesh(const char *filename, Mesher &mesher) {
        ofstream out;
        out.open(filename);
        out.precision(numeric_limits<double>::digits10 + 1);

        if (!out) { // file couldn't be opened
            cerr << "Error: file could not be opened" << endl;
            return false;
        }

        out << "ply" << endl;
        out << "format ascii 1.0" << endl;
        out << "comment Mesh generated by the Ball Pivoting Algorithm" << endl;
        out << "element vertex " << mesher.nVertices() << endl;
        out << "property float x" << endl;
        out << "property float y" << endl;
        out << "property float z" << endl;
        out << "property float nx" << endl;
        out << "property float ny" << endl;
        out << "property float nz" << endl;
        out << "element face " << mesher.nFacets() << endl;
        out << "property list uchar int vertex_indices" << endl;
        out << "end_header" << endl;

        for (Vertex_star_list::const_iterator vi = mesher.vertices_begin();
             vi != mesher.vertices_end(); ++vi) {
            Vertex *v = *vi;
            out << *v << endl;
        }

        for (Facet_star_list::const_iterator fi = mesher.facets_begin();
             fi != mesher.facets_end(); ++fi) {
            out << 3 << "\t";
            const Facet *f = *fi;

            Vertex *v0 = f->vertex(0);
            Vertex *v1 = f->vertex(1);
            Vertex *v2 = f->vertex(2);

            double nx = v0->nx() + v1->nx() + v2->nx();
            double ny = v0->ny() + v1->ny() + v2->ny();
            double nz = v0->nz() + v1->nz() + v2->nz();

            double tx = v1->x() - v0->x();
            double ty = v1->y() - v0->y();
            double tz = v1->z() - v0->z();

            double sx = v2->x() - v0->x();
            double sy = v2->y() - v0->y();
            double sz = v2->z() - v0->z();

            double cprodx, cprody, cprodz;
            cross_product(tx, ty, tz, sx, sy, sz, cprodx, cprody, cprodz);


            if (nx * cprodx + ny * cprody + nz * cprodz > 0) {
                out << v0->index() << "\t";
                out << v1->index() << "\t";
                out << v2->index() << endl;
            } else {
                out << v0->index() << "\t";
                out << v2->index() << "\t";
                out << v1->index() << endl;
            }
        }
        return true;
    }


    void FileIO::saveContent(OctreeNode *node, ofstream &f) {
        if (node->getDepth() != 0) {
            for (int i = 0; i < 8; i++)
                if (node->getChild(i) != NULL)
                    saveContent(node->getChild(i), f);
        } else if (node->getNpts() != 0) {
            Vertex_list::const_iterator iter;
            for (iter = node->points_begin(); iter != node->points_end();
                 ++iter) {
                f << *iter << std::endl;
            }
        }
    }

}